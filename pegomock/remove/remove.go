package remove

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func Remove(
	path string,
	recursive bool,
	shouldConfirm bool,
	dryRun bool,
	silent bool,
	out io.Writer,
	in io.Reader,
	removeFn func(path string) error) {
	filepaths := make([]string, 0)
	if recursive {
		filepath.Walk(path, func(path string, info os.FileInfo, err error) error {
			if !info.IsDir() && isPegomockGenerated(path, out) {
				filepaths = append(filepaths, path)
			}
			return nil
		})
	} else {
		fileInfos, e := ioutil.ReadDir(path)
		if e != nil {
			fmt.Fprintln(out, "Could not get files in path "+path)
			return
		}
		for _, info := range fileInfos {

			if !info.IsDir() && isPegomockGenerated(filepath.Join(path, info.Name()), out) {
				filepaths = append(filepaths, filepath.Join(path, info.Name()))
			}
		}
	}
	if len(filepaths) == 0 {
		fmt.Fprintln(out, "No files to remove.")
		return
	}
	if dryRun {
		fmt.Fprintln(out, "This is a dry-run. Would delete the following files:")
		fmt.Fprintln(out, strings.Join(filepaths, "\n"))
		return
	}

	if shouldConfirm {
		fmt.Fprintln(out, "Will delete the following files:")
		fmt.Fprintln(out, strings.Join(filepaths, "\n"))
		if !askForConfirmation("Continue?", in, out) {
			return
		}
	} else if !silent {
		fmt.Fprintln(out, "Deleting the following files:")
		fmt.Fprintln(out, strings.Join(filepaths, "\n"))
	}

	var errs []error
	for _, filepath := range filepaths {
		e := removeFn(filepath)
		if e != nil {
			errs = append(errs, e)
		}
	}
	if len(errs) > 0 {
		fmt.Fprintf(out, "There were some errors when trying to delete files: %v", errs)
	}
}

func isPegomockGenerated(path string, out io.Writer) bool {
	file, e := os.Open(path)
	if e != nil {
		fmt.Fprintf(out, "Could not open file %v. Error: %#v\n", path, e)
	}
	b := make([]byte, 50)
	_, e = file.Read(b)
	if e != nil {
		fmt.Fprintf(out, "Could not read from file %v. Error: %#v\n", path, e)
	}
	if strings.Contains(string(b), "// Code generated by pegomock. DO NOT EDIT.") {
		return true
	}
	return false
}

func askForConfirmation(s string, in io.Reader, out io.Writer) bool {
	reader := bufio.NewReader(in)

	for {
		fmt.Fprintf(out, "%s [y/n]: ", s)

		response, err := reader.ReadString('\n')
		if err != nil {
			fmt.Fprintln(out, "Could not get confirmation from StdIn", err)
			return false
		}

		response = strings.ToLower(strings.TrimSpace(response))

		if response == "y" || response == "yes" {
			return true
		} else if response == "n" || response == "no" {
			return false
		}
	}
}
